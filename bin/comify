#!/usr/bin/env python3

import sys
import re

underline = "\033[4m"
no_underline = "\033[24m"

def left_to_right(val_str):
    return False, [val_str[i:i+3] for i in range(0, len(val_str), 3)]

def right_to_left(val_str):
    retval = []
    while val_str:
        retval.append(val_str[-3:])
        val_str = val_str[0:-3]
    retval.reverse()
    return not bool(len(retval)%2), retval

def mark_triples(val_str, direction):
    retval = ''
    flop, triples = direction(val_str)
    for tri in triples:
        if flop:
            retval += underline + tri + no_underline
        else:
            retval += tri
        flop = not flop
    return retval

frac_re = re.compile('(.*\.)(\d{4,})(.*)')
#Tricky bit: the '.*?' is important, to keep the .* from greedy-matching. Otherwise, the \d{4,} will
#only ever be able to match 4 values. My lazy-matching with the '.*?', we leave as many digits as 
#possible for the second group.
int_re = re.compile('(.*?)(\d{4,})(.*)')
def mark_floats(val_str):
    for regex, direction in [(frac_re, left_to_right), (int_re, right_to_left)]:
        match = re.match(regex, val_str)
        while match:
            g = match.groups()
            val_str = g[0] + mark_triples(g[1], direction) + g[2]
            match = re.match(regex, val_str)
    return val_str

field_id = None
if len(sys.argv) == 3 and sys.argv[1] == '-f':
    field_id = int(sys.argv[2])

re_fieldbreak = re.compile('\s*\S+\s*')
re_digitgroups = re.compile('\d{4,}')
for line in sys.stdin.readlines():
    line = line.strip()
    left = ''
    field = line
    right = ''
    if field_id is not None:
        matches = re_fieldbreak.findall(line)
        if len(matches) >= field_id:
            left = ''.join(matches[:field_id])
            field = matches[field_id]
            right = ''.join(matches[field_id+1:])

    print (left + mark_floats(field) + right)
