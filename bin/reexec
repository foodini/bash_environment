#!/usr/bin/env python3

#TODO
# * Remove the requirement that the file be executed.  You need to be able
#   to provide a command.  (reexec foo.c "gcc foo.c")
# * Need better error message when executable not found. For example;
#   reexec graph.py graph.py instead of reexec ./graph.py ./graph.py

import sys
import os.path
import time
import subprocess
import select
import inspect

def mark():
  print(inspect.currentframe().f_back.f_lineno)

def execute(cmd):
  tsk = subprocess.Popen(cmd,stdout=subprocess.PIPE,stderr=subprocess.PIPE)

  poll = select.poll()
  poll.register(tsk.stdout,select.POLLIN | select.POLLHUP)
  poll.register(tsk.stderr,select.POLLIN | select.POLLHUP)
  pollc = 2

  events = poll.poll()
  while pollc > 0 and len(events) > 0:
    for event in events:
      (rfd,event) = event
      if event & select.POLLIN:
        if rfd == tsk.stdout.fileno():
          line = tsk.stdout.readline()
          if len(line) > 0:
            print(line[:-1].decode())
        if rfd == tsk.stderr.fileno():
          line = tsk.stderr.readline()
          if len(line) > 0:
            print(line[:-1].decode())
      if event & select.POLLHUP:
        poll.unregister(rfd)
        pollc = pollc - 1
      if pollc > 0: events = poll.poll()
  sys.stdout.flush()
  tsk.wait()

def which(program):
  import os
  def is_exe(fpath):
    return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

  fpath, fname = os.path.split(program)
  if fpath:
    if is_exe(program):
      return program
  else:
    for path in os.environ["PATH"].split(os.pathsep):
      path = path.strip('"')
      exe_file = os.path.join(path, program)
      if is_exe(exe_file):
        return exe_file

  return None

executable = which(sys.argv[1])

first_time = True
prev_mod_time = time.ctime(os.path.getmtime(executable))
while True:
  cur_mod_time = time.ctime(os.path.getmtime(executable))
  if cur_mod_time > prev_mod_time or first_time:
    if not first_time:
      print()
    execute(sys.argv[1:])
    print('================')
    first_time = False
    start_time = time.time()
  else:
    print('\b\b\b\b\b\b%6d' % int(time.time() - start_time),
        end='', flush=True)
  prev_mod_time = cur_mod_time
  time.sleep(1)
