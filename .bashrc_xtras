# To deal with Fucked-up macs that can't get their shit together:
alias a=~/bin/a

if [[ $TERM == "cygwin" ]]; then
  export SHELLOPTS
  set -o igncr
fi

source ~/bin/color_swatch

export PC_PREFERRED=$PC_WHITE
export ESC_PREFERRED=$ESC_WHITE
alias tb='timer && beep'

#######################Per-machine configurations###############################
case $HOSTNAME in
ron-desktop)
  export PC_PREFERRED=$PC_BROWN
  export ESC_PREFERRED=$ESC_BROWN
  export PATH=$PATH:$HOME/bin/cygwin
  export STATUS_LINE_SUPPORT=cygwin
  ;;
fit-pc)
  export PC_PREFERRED=$PC_GREEN
  export ESC_PREFERRED=$ESC_GREEN
  export STATUS_LINE_SUPPORT=linux
  ;;
box481.*)
  export PC_PREFERRED=$PC_CYAN
  export ESC_PREFERRED=$ESC_CYAN
  export HISTTIMEFORMAT=''
  export STATUS_LINE_SUPPORT=linux
  ;;
tw-mbp-rbarry)
  export PC_PREFERRED=$PC_PURPLE
  export ESC_PREFERRED=$ESC_PURPLE
  export PATH=$PATH:$HOME/local/avr/bin
  #Because OSX defaults to always using grep color, even if output is piped or
  #redirected. Morons.
  alias grep='grep --color=auto'
  function idea {
  ~/bin/status_time ./pants goal idea expandodo/core:: expandodo/caps:: expandodo/card-data-handler:: --idea-project-name=$@
  }
  export STATUS_LINE_SUPPORT="mac"
esac
################################################################################


export PATH=$PATH:~/bin

export COMP_TMP="$HOME/tmp/$BASHPID.sh"
bind -x '"\eo":"expand_scm -o $COMP_TMP; source $COMP_TMP; rm $COMP_TMP"'
bind -x '"\en":"expand_scm -c $COMP_TMP; source $COMP_TMP; rm $COMP_TMP"'
bind -x '"\eh":"expand_history $COMP_TMP; source $COMP_TMP; rm $COMP_TMP"'

#less -R preserves color and underline formatting, which I use addictively:
alias less='less -R'

alias rerc='source ~/.bashrc_xtras'
alias virc='vi ~/.bashrc_xtras'
alias fxgrep='find . -type f | xargs grep --color=auto'
alias fgrep='find . | grep --color=never'

source ~/.bashrc_remote
export EDITOR='vim'

source ~/bin/acd_func.sh

#LOGFILE="$HOME/bashlogs/$BASHPID"

################################################################################
#I want these commands to always use color, unless the command is being
#redirected to a file.  I'm sure I'll have to make changes as I find issues.
function a {
  if [[ "$CMD" =~ '>' ]]; then
  ls -al --color=auto "$@"
  else
  ls -al --color=always "$@" | comify -f 4
  fi
}

function grep {
  if [[ "$CMD" =~ '>' ]]; then
  /usr/bin/grep --color=auto "$@"
  else
  /usr/bin/grep --color=always "$@"
  fi
}

#This one exists specifically to hilight output, so why protect it from
#redirection?
function hl {
  egrep --color=always "(^)|($1)"
}
################################################################################

#Todo:
#If you put slashes in here, make SURE they are escaped with a backslash!!!
replace_substrings() {
  if [ $BASE == $PWD ]; then
      BACKREF=$1
      CRUFT=$2
      SUB=$3
      SUB_BNW=$4
      BASE=`echo $PWD|sed -e "s/^$CRUFT.*/$SUB/g"`
      BASE_BNW=`echo $PWD|sed -e "s/^$CRUFT.*/$SUB_BNW/g"`
      TRIM=`echo $PWD|sed -e "s/^$CRUFT\(.*\)/$BACKREF/g"`
  fi
}

gen_prompt_text() {
  LAST_RETURN_VAL=$?
  #echo $LAST_RETURN_VAL >> $LOGFILE
  #date >> "$LOGFILE"
  #echo >> "$LOGFILE"

  if [ $LAST_RETURN_VAL == 0 ]; then
      PC_BASE_COL=$PC_PREFERRED
      ESC_BASE_COL=$ESC_PREFERRED
  else
      PC_BASE_COL=$PC_RED
      ESC_BASE_COL=$ESC_RED
  fi

  HOST_SHORT=`hostname | cut -f1 -d.`

  BASE=$PWD
  TRIM=$PWD

  #replace_substrings takes;
  # * This is the worst bit, and I'll try to figure it out later.  You
  #   have to provide the regular expression backreference ONE BEYOND the
  #   last one you use.  If you don't use any (or you don't know what I'm
  #   talking about, use "\1".  If you use one backreference in the
  #   second argument, use "\2".  Etc.  It's used to extract the last
  #   portion of your current working directory.
  # * a regular expression match for the bit you want to chop off at the
  #   beginning 
  # * the string to replace the regex with in colorized prompts.  You don't
  #   have to use color.  If you don't this argument and the next will be
  #   the same.
  # * the string to replace the regex with in colorless prompts.
  case $HOSTNAME in
  tw-mbp-rbarry)
    replace_substrings "\1" ".Users.rbarry"\
    "$ESC_BOLD${ESC_GREEN}~$ESC_RESET$ESC_BASE_COL" "~"
    ;;
  fit-pc)
    replace_substrings "\1" ".home.ronb"\
    "$ESC_BOLD${ESC_GREEN}~$ESC_RESET$ESC_BASE_COL" "~"
    ;;
  box481.*)
    replace_substrings "\1" ".home1.foodinio"\
    "$ESC_BOLD${ESC_GREEN}~$ESC_RESET$ESC_BASE_COL" "~"
    ;;
  esac

  # If none of the above clauses have matched, TRIM is all we're going to
  # display after the hostname, so clear BASE and BASE_BNW
  if [ $BASE == $PWD ]; then
    BASE=""
    BASE_BNW=""
  fi

  if [ ${#TRIM} -gt 37 ]; then
      #TRIM=`echo $TRIM|sed -e "s/^.*\(.\{37\}\)$/\\1/"`
      #TRIM="...$TRIM"
      TRIM=`echo $TRIM|sed -e "s/^.*\(.\{37\}\)$/...\\1/"`
  fi

  PROMPT_COL="$PC_BASE_COL$TRIM$PC_RESET"

  export PROMPT_BNW="$HOST_SHORT: $BASE_BNW$TRIM> "
  export PROMPT_COL="$PC_UNDER$PC_BASE_COL$HOST_SHORT$PC_UNDER_OFF: $BASE$PROMPT_COL> "
  if [ $STATUS_LINE_SUPPORT == "linux" ]; then
      export PS1="\[\e]0;$PROMPT_BNW\a\]$PROMPT_COL"
  elif [ $STATUS_LINE_SUPPORT == "mac" ]; then
      export PS1="\[\e]0;$PROMPT_BNW\a\]$PROMPT_COL"
  else
      export PS1=$PROMPT_COL
  fi
}

export PROMPT_COMMAND='gen_prompt_text'

#TODO: The trap fires a number of times in the execution of a command.
#      How can I trim it down so the trap is turned off until the end of
#      next prompt generation phase AND use $BASH_COMMAND instead of this
#      ugly history | sed thing?  ($BASH_COMMAND, during the execution of
#      gen_prompt_text is "gen_prompt_text")
if [ $STATUS_LINE_SUPPORT == "linux" ]; then
  trap 'if [ "$BASH_COMMAND" == "gen_prompt_text" ]; then CMD=""; else CMD=$BASH_COMMAND;fi;echo -en "\e]0;$PROMPT_BNW$CMD\007"' DEBUG
elif [ $STATUS_LINE_SUPPORT == "mac" ]; then
  # The mac uses \x1B instead of \e:
  trap 'if [ "$BASH_COMMAND" == "gen_prompt_text" ]; then CMD=""; else CMD=$BASH_COMMAND;fi;echo -en "\x1B]0;$PROMPT_BNW$CMD\a"' DEBUG
fi
