# * Get bash logging working.  Do a mkdir -p for ~/tmp early, since this and
#   expand_p4_path depend upon it.
# * Set the default prompt hostname color in here, if you're still going to use
#   one.
# * de-dupe the PATH. (might be able to use a python OrderedSet on the CL.

#set -xv

function pathmod() {
  if [[ ":$PATH:" != *":$1:"* ]]; then
    export PATH=$2
  fi
}

function pathpre() {
  pathmod "$1" "$1:$PATH"
}

function pathpost() {
  pathmod "$1" "$PATH:$1"
}

pathpost "$HOME/bin"

if [[ $TERM == "cygwin" ]]; then
  export SHELLOPTS
  set -o igncr
fi

export P4_BINARY_LOCATION='/usr/local/bin/p4'

source ~/bin/color_swatch

export PC_PREFERRED=$PC_WHITE
export ESC_PREFERRED=$ESC_WHITE

alias tb='ntt ~/bin/timer 9:00 && beep'
alias timer='ntt ~/bin/timer'
#less -R preserves color and underline formatting, which I use addictively:
alias less='less -R'
alias rerc='source ~/.bashrc_xtras'
alias virc='vi ~/.bashrc_xtras'
alias vilo='vi ~/.bash_logout_xtras'
alias g='git status'
export EDITOR='vim'
export GREPLOC=/bin/grep
#I get sick of doing grep --line-buffered. I can just do grep $B
export B=--line-buffered

bind -x '"\eo":"expand_scm -o $COMP_TMP; source $COMP_TMP; rm $COMP_TMP"'
bind -x '"\en":"expand_scm -c $COMP_TMP; source $COMP_TMP; rm $COMP_TMP"'
bind -x '"\eh":"expand_history $COMP_TMP; source $COMP_TMP; rm $COMP_TMP"'

shopt -s histappend

HISTSIZE=500
HISTFILESIZE=5000

#######################Per-machine configurations###############################
case $HOSTNAME in
1847JGH6*|ip-10-1-2-228*)
  #fab stage deploy.restart_supervisor
  ssh-add -K ~/.ssh/id_rsa_victor_shared 2> /dev/null > /dev/null
  ssh-agent > /dev/null

  export P4PORT=p4.tinyco.com:1667
  export P4USER=ron

  export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python
  export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/bin/virtualenv
  export VIRTUALENVWRAPPER_VIRTUALENV_ARGS="--no-site-packages"


  export GREPLOC=/usr/bin/grep
  export PLATFORM="OSX"
  export PC_PREFERRED=$PC_GREEN
  export ESC_PREFERRED=$ESC_GREEN
  export GIT_BINARY_LOCATION=/usr/bin/git

  # 
  #if [ -f $(which virtualenvwrapper.sh) ]; then
  #  source $(which virtualenvwrapper.sh)
  #fi
  #

  alias up="cd \"\$(git rev-parse --show-toplevel)\""
  alias gpo='git push origin $BRANCH'
  alias gl='git log | head -1 | cut -f2 -d\  | tr -d "\\n"  | pbcopy && pbpaste && echo \ added to clipboard'

  #Anki-specific
  alias vic='cd ~/workspace/victor'
  alias vos='cd ~/workspace/vicos-oelinux'
  alias sp='cd ~/workspace/victor/project/victor/simpleperf'
  alias perf='cd ~/workspace/victor/project/victor/simpleperf'
  alias tut='cd ~/workspace/victor/tools/sdk/vector-python-sdk-private/sdk/examples/tutorials'
  alias sdk='cd ~/workspace/victor/tools/sdk/vector-python-sdk-private/sdk'
  #export GOBIN=~/go/bin
  export GOPATH=/Users/ronb/workspace/victor/cloud/go:/Users/ronb/workspace/victor/generated/cladgo:/Users/ronb/workspace/victor/generated/go:/Users/ronb/workspace/victor/tools/message-buffers/support/go
  pathpost /usr/local/go/bin
  pathpost "/Applications/Visual Studio Code.app/Contents/Resources/app/bin"
  source ~/workspace/victor/project/victor/scripts/usefulALiases.sh
  function localbot {
    echo export ANKI_ROBOT_HOST=localhost > ~/bot_state.sh
    echo export ANKI_ROBOT_SERIAL=>> ~/bot_state.sh
    echo export ANKI_ROBOT_NAME=>> ~/bot_state.sh
    echo export ANKI_ROBOT_ALIAS='local' >> ~/bot_state.sh
  }
  function perfbot {
    echo export ANKI_ROBOT_HOST=192.168.41.101 > ~/bot_state.sh
    echo export ANKI_ROBOT_SERIAL=00E10064 >> ~/bot_state.sh
    echo export ANKI_ROBOT_NAME=E2A5 >> ~/bot_state.sh
    echo export ANKI_ROBOT_ALIAS='profile' >> ~/bot_state.sh
  }
  function relbot {
    echo export ANKI_ROBOT_HOST=192.168.41.34 > ~/bot_state.sh
    echo export ANKI_ROBOT_SERIAL=00800124 >> ~/bot_state.sh
    echo export ANKI_ROBOT_NAME=T5Y3 >> ~/bot_state.sh
    echo export ANKI_ROBOT_ALIAS='vanilla' >> ~/bot_state.sh
  }

  bind -x '"˙":"expand_history $COMP_TMP; source $COMP_TMP"'
  bind -x '"ø":"expand_scm -o $COMP_TMP; source $COMP_TMP"'
  pathpre "/usr/local/Cellar/ctags/5.8/bin"

  export VSQL_DATABASE=bizint
  export VSQL_HOST=10.20.0.110
  export VSQL_USER=rbarry
  ;;
ron-desktop)
  export PLATFORM="WIN"
  export PC_PREFERRED=$PC_BROWN
  export ESC_PREFERRED=$ESC_BROWN
  pathpost "$HOME/bin/cygwin"
  ;;
box481.*)
  export PLATFORM="LINUX"
  export PC_PREFERRED=$PC_CYAN
  export ESC_PREFERRED=$ESC_CYAN
  ;;
perforce)
  export PLATFORM="LINUX"
  export PC_PREFERRED=$PC_BLUE
  export ESC_PREFERRED=$ESC_BLUE
  ;;
esac
################################################################################

case $TERM in
  xterm|screen|xterm-256color)
    export SUPPORTS_STATUS_LINE="true"
    ;;
  *)
    export SUPPORTS_STATUS_LINE="false"
    ;;
esac

if [ "$BASHPID" == "" ]; then
  echo "Holy Ancient Versions, Bashman! (Upgrade to 4.something.)"
fi

export COMP_TMP="$HOME/tmp/$BASHPID.sh"
source ~/bin/acd_func.sh

LOGFILE="$HOME/bashlogs/$BASHPID"

################################################################################
#I want these commands to always use color, unless the command is being
#redirected to a file.  I'm sure I'll have to make changes as I find issues.
function a {
  if [[ "$CMD" =~ '>' ]]; then
    ls -al "$@"
  else
    if [[ "$PLATFORM" == "OSX" ]]; then
      CLICOLOR_FORCE=1 ls -al "$@" | comify -f 4
    else
      ls -al --color=always "$@" | comify -f 4
    fi
  fi
}

function grep {
  if [[ -t 1 ]]; then
    $GREPLOC -E --color=always "$@"
  else
    $GREPLOC -E --color=never "$@"
  fi
}

function fgrep {
  if [[ -t 1 ]]; then
    find . | $GREPLOC -E --color=always "$@"
  else
    find . | $GREPLOC -E --color=never "$@"
  fi
}

function fc {
    grep \\W"$@"\\W ~/workspace/victor/robot/include/anki/cozmo/shared/factory/faultCodes.h
}

# fxgrep takes all args up to and including the first that doesn't start with
# '-' and does a find . | grep [everything else] | xargs grep [first arg set]
# If there's only one arg not beginning with '-': find . | xargs grep [args]
#
# I'd still like a way to point fxgrep at a directory, but I'm not sure what to
# do with the syntax. fxgrep [directory] -- [first grep args] [second args] ?
# Require each arg/argset to be quoted?
#
#TODO: fix: fxgrep "foo bar" "yodeling yoda" - quotes lost in constructed command.
function fxgrep {
  declare -a FILE_FILTER=()
  declare -a LINE_FILTER=("-H")
  FOUND_DELIMITER="false"
  for i in "$@"; do  #Quoting makes it accept quoted args as single args
    if [[ $FOUND_DELIMITER == "false" ]]; then
      LINE_FILTER+=($i)
      if [[ ${i:0:1} != "-" ]]; then
        FOUND_DELIMITER="true"
      fi
    else
      FILE_FILTER+=($i)
    fi
  done

  if [[ -t 1 ]]; then
    WHEN_COLOR="always"
  else
    WHEN_COLOR="never"
  fi
  if [[ "$FILE_FILTER" != "" ]]; then
    FILE_FILTER="$FILE_FILTER"
  else
    FILE_FILTER="^"
  fi

  # When you leave variables unquoted (e.g., $LINE_FILTER instead of "$LINE_FILTER"), it affects
  # the interpolation of special characters in the variable. But I would expect quoting to work
  # and unquoted to fail (http://www.tldp.org/LDP/abs/html/quotingvar.html), but this is working
  # for now. I never want to touch this again. Actually, I REALLY need to set up test cases for
  # this thing if I ever touch it again.

  # Tell the for loop to only use \n as a delimiter. Otherwise, spaces in filenames will cause
  # splits. Note that IFS affects how arrays are joined, as well. Evidently, I could have avoided
  # this entire nightmare with eval.
  IFS=$'\n'
  #for i in `find . -type f | $GREPLOC -E ${FILE_FILTER[*]}`; do file $i; done | grep text | cut -f1 -d: | ds | xargs $GREPLOC -E --color=$WHEN_COLOR ${LINE_FILTER[*]}
  find . -type f | $GREPLOC -E ${FILE_FILTER[*]} | ds | xargs $GREPLOC -E --color=$WHEN_COLOR ${LINE_FILTER[*]}
}

function pygrep() {
  fxgrep $@ [.]py$
}

function cgrep() {
  fxgrep $@ "[.]((h)|(cpp)|(c[+]*))$"
}

function ggrep() {
  fxgrep $@ [.]go$
}

#This one exists specifically to hilight output, so why protect it from
#redirection?
function hl {
  egrep --color=always "(^)|($1)"
}
################################################################################


#Todo:
# * Add total logging: write $CMD, it's return value, start and end time to a
#   log file somewhere?
# * Get rid of hostname when you're on localhost?  (how?)
# * (on fit-pc, anyway) I'm still seeing the previous command flash up when a
#   blank line is entered
# * move the color definitions to a different file?
#If you put slashes in here, make SURE they are escaped with a backslash!!!
replace_substrings() {
    if [ $BASE == $PWD ]; then
        BACKREF=$1
        CRUFT=$2
        SUB=$3
        SUB_BNW=$4
        BASE=`echo $PWD|sed -e "s/^$CRUFT.*/$SUB/g"`
        BASE_BNW=`echo $PWD|sed -e "s/^$CRUFT.*/$SUB_BNW/g"`
        TRIM=`echo $PWD|sed -e "s/^$CRUFT\(.*\)/$BACKREF/g"`
    fi
}

debug_echo() {
  #echo $@
  echo -en ""
}

if [ "$TIMER_PID" != "" ]; then
  kill -9 $TIMER_PID
fi
if [ -e "$LOGFILE" ]; then
  rm -f $LOGFILE
fi
bash_timer_manager $LOGFILE & export TIMER_PID=$!

#function names must be >= 3 characters.
ntt() {
  if [ -e "$LOGFILE" ]; then
    rm $LOGFILE
  fi
  $@
}

start_timer() {
  #TODO: get this the hell out of anything not anki-related
  source ~/bot_state.sh
  if [[ "$TIMER" == "false" ]]; then
    stop_timer
  else
    if [ ! -e "$LOGFILE" ]; then
      CMD=`history | tail -1 | tr -s " " | cut -f3-1000 -d" "`
      echo "$PROMPT_BNW $CMD" > $LOGFILE
    fi
  fi
}

stop_timer() {
  if [ -e "$LOGFILE" ]; then
    rm -f $LOGFILE
  fi
}

join_list() {
    RESULT=""
    GLUE=$1
    if [ "$2" != "" ]; then
        RESULT="$2"
    fi
    if [ "$3" != "" ]; then
        if [ "$RESULT" == "" ]; then
            RESULT="$3"
        else
            RESULT="$RESULT$GLUE$3"
        fi
    fi
    if [ "$4" != "" ]; then
        if [ "$RESULT" == "" ]; then
            RESULT="$4"
        else
            RESULT="$RESULT$GLUE$4"
        fi
    fi

    JOIN_LIST_RESULT="$RESULT"
}

gen_prompt_text() {
    history -a
    LAST_RETURN_VAL=$?
    #echo $LAST_RETURN_VAL >> $LOGFILE
    #date >> "$LOGFILE"
    #echo >> "$LOGFILE"

    if [ $LAST_RETURN_VAL == 0 ]; then
        PC_BASE_COL=$PC_PREFERRED
        ESC_BASE_COL=$ESC_PREFERRED
    else
        PC_BASE_COL=$PC_RED
        ESC_BASE_COL=$ESC_RED
    fi

    HOST_SHORT=`hostname | cut -f1 -d.`

    BASE=$PWD
    TRIM=$PWD

    set_term_bgcolor_for_state $BASE

    #replace_substrings takes;
    # * This is the worst bit, and I'll try to figure it out later.  You
    #   have to provide the regular expression backreference ONE BEYOND the
    #   last one you use.  If you don't use any (or you don't know what I'm
    #   talking about, use "\1".  If you use one backreference in the
    #   second argument, use "\2".  Etc.  It's used to extract the last
    #   portion of your current working directory.
    # * a regular expression match for the bit you want to chop off at the
    #   beginning 
    # * the string to replace the regex with in colorized prompts.  You don't
    #   have to use color.  If you don't this argument and the next will be
    #   the same.
    # * the string to replace the regex with in colorless prompts.
    case $HOSTNAME in
    fzzt.*)
      replace_substrings "\1" ".usr.local.google.home.rbarry"\
           "$ESC_BOLD${ESC_GREEN}~${ESC_BASE_COL}$ESC_BOLD_OFF" "~"
      replace_substrings "\1" \
           ".google.src.cloud.rbarry.rbarry-get_[^n]*name"\
           "$ESC_BOLD${ESC_GREEN}{GDBN}${ESC_BASE_COL}$ESC_BOLD_OFF" "{GDBN}"
      replace_substrings "\1" ".google.src.cloud.rbarry.rbarry-trusted[^\/]*"\
           "$ESC_BOLD${ESC_GREEN}{TTW}${ESC_BASE_COL}$ESC_BOLD_OFF" "{TTW}"
      replace_substrings "\1" ".google.src.cloud.rbarry.rbarry-user_can_[^\/]*"\
           "$ESC_BOLD${ESC_GREEN}{UCCAD}${ESC_BASE_COL}$ESC_BOLD_OFF" "{UCCAD}"
      replace_substrings "\2" ".google.src.cloud.rbarry.rbarry-\([^\/]*\)"\
           "$ESC_BOLD${ESC_GREEN}{\\1}${ESC_BASE_COL}$ESC_BOLD_OFF" "{\\1}"
      ;;
    fit-pc)
      replace_substrings "\1" ".home.ronb"\
           "$ESC_BOLD${ESC_GREEN}~${ESC_BASE_COL}$ESC_BOLD_OFF" "~"
      ;;
    box481.*)
      replace_substrings "\1" ".home1.foodinio"\
           "$ESC_BOLD${ESC_GREEN}~${ESC_BASE_COL}$ESC_BOLD_OFF" "~"
      ;;
    esac

    # If none of the above clauses have matched, TRIM is all we're going to
    # display after the hostname, so clear BASE and BASE_BNW
    if [ "$BASE" == "$PWD" ]; then
      BASE=""
      BASE_BNW=""
    fi

    if [ ${#TRIM} -gt 37 ]; then
        #TRIM=`echo $TRIM|sed -e "s/^.*\(.\{37\}\)$/\\1/"`
        #TRIM="...$TRIM"
        TRIM=`echo $TRIM|sed -e "s/^.*\(.\{37\}\)$/...\\1/"`
    fi

    PROMPT_COL="$PC_BASE_COL$TRIM$PC_RESET"

    BRANCH=`$GIT_BINARY_LOCATION branch 2>&1 | grep '^\*' | cut -c3-`
    VIRTENV=`echo $VIRTUAL_ENV | cut -d/ -f5`
    join_list " " "$BRANCH" "$VIRTENV" "$ANKI_ROBOT_ALIAS"
    CONTEXT=$JOIN_LIST_RESULT
    if [ "$CONTEXT" != "" ]; then
        CONTEXT="($CONTEXT)"
    fi
    TIME=`date +%I:%M`
    #TODO: Make it so only work leaves out the host?
    #export PROMPT_BNW="$HOST_SHORT $TIME $CONTEXT$BASE_BNW$TRIM> "
    #export PROMPT_COL="$PC_UNDER$PC_BASE_COL$HOST_SHORT$PC_UNDER_OFF $TIME $CONTEXT$BASE$PROMPT_COL> "
    export PROMPT_BNW="$TIME $CONTEXT$BASE_BNW$TRIM> "
    #export PROMPT_COL="╔═ $PC_BASE_COL$TIME $CONTEXT$BASE$PROMPT_COL\\n╚═ "
    #export PROMPT_COL="╔>$PC_BASE_COL$TIME $CONTEXT$BASE$PROMPT_COL\\n╚>"
    export PROMPT_COL="╓$PC_BASE_COL$TIME $CONTEXT$BASE$PROMPT_COL\\n╙"
    if [ $SUPPORTS_STATUS_LINE == "true" ]; then
        export PS1="\[\033]0;$PROMPT_BNW\a\]$PROMPT_COL"
    else
        export PS1=$PROMPT_COL
    fi

    stop_timer
}

export PROMPT_COMMAND='gen_prompt_text'

if [ $SUPPORTS_STATUS_LINE == "true" ]; then
    trap 'start_timer' DEBUG
    # Doesn't get run. I haven't debugged why. For the moment, I stop the timer in
    # the prompt_command
    #trap 'stop_timer' RETURN
fi

function git() {
    GIT_PAUSE="false"
    if [[ "$1" == "clone" && "$2" != *"ssh://git@github"* ]]; then
        echo !!!!!!!!!!! are you sure you are cloning properly? !!!!!!!!
        echo !!!!!!!!!! maybe.... git clone ssh://git@github.... !!!!!!!
        GIT_PAUSE="true"
    fi
    declare -a patterns=("ipdb" "DO.NOT.SUBMIT" "^\+.{120}")
    ARGS=""
    if [[ "$1" == "add" ]]; then
        ARGS=" "
    elif [[ "$1" == "commit" ]]; then
        ARGS="--staged"
    fi
    if [[ "$ARGS" != "" ]]; then
        for PATTERN in "${patterns[@]}"; do
            if [[ `$GIT_BINARY_LOCATION diff $ARGS | grep -e $PATTERN | wc -l` != "       0" ]]; then
                echo !!!!!!!!!!!!!!!!!!!!!   what\'s $PATTERN doing in there\?   !!!!!!!!!!!!!!!!!!
                GIT_PAUSE="true"
            fi
        done
    fi
    if [[ "$GIT_PAUSE" == "true" ]]; then
        sleep 5
    fi

    $GIT_BINARY_LOCATION $@
}

function figit() {
    TXT=$1
    EMO1=$2
    EMO2=$3
    figlet -f 3x5 $TXT | sed -e "s/ /:$EMO1:/g" | sed -e "s/#/:$EMO2:/g" | tail -5
}

ssh() {
  set_term_bgcolor_for_state "$@"
  /usr/bin/ssh $@
}

bing() {
  ping "$@" | grep --line-buffered bytes.from.*icmp_seq | beep
}

set_term_bgcolor_for_state() {
    local STATE=$1
    if [[ $STATE == *marvel* ]]; then
        set_term_bgimage /Users/ronbarry/background_images/marvel.jpg
    elif [[ $STATE == *fgser* ]]; then
        set_term_bgimage /Users/ronbarry/background_images/familyguy.png
    elif [[ $STATE == *tinyservicelib* ]]; then
        set_term_bgimage /Users/ronbarry/background_images/tsl2.png
    elif [[ $STATE == *workspace/gae* ]]; then
        set_term_bgimage /Users/ronbarry/background_images/gae.png
    elif [[ $STATE == *erverama* ]]; then
        #set_term_bgimage /Users/ronbarry/background_images/hypno.gif
        set_term_bgimage /Users/ronbarry/background_images/hypno.gif
    elif [[ $STATE == *harry* ]]; then
        set_term_bgimage /Users/ronbarry/background_images/hp.jpg
    elif [[ $STATE == *ronbarry* ]]; then
        set_term_bgcolor 0 0 40
    else
        set_term_bgcolor 0 0 0
    fi
}

set_term_bgimage(){
  /usr/bin/osascript <<EOF
tell application "iTerm"
  tell the current window
    tell the current session
      set background image to "$1"
    end tell
  end tell
end tell
EOF
}

set_term_bgcolor(){
  local R=$1
  local G=$2
  local B=$3
  /usr/bin/osascript <<EOF
tell application "iTerm"
  tell the current window
    tell the current session
      set background image to ""
      set background color to {$(($R*65535/255)), $(($G*65535/255)), $(($B*65535/255))}
    end tell
  end tell
end tell
EOF
}
