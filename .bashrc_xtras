# * Get bash logging working.  Do a mkdir -p for ~/tmp early, since this and
#   expand_p4_path depend upon it.
# * Set the default prompt hostname color in here, if you're still going to use
#   one.

if [[ $TERM == "cygwin" ]]; then
  export SHELLOPTS
  set -o igncr
fi

export P4_BINARY_LOCATION='/usr/local/bin/p4'

source ~/bin/color_swatch

export PC_PREFERRED=$PC_WHITE
export ESC_PREFERRED=$ESC_WHITE

alias tb='timer && beep'
#less -R preserves color and underline formatting, which I use addictively:
alias less='less -R'
alias rerc='source ~/.bashrc_xtras'
alias virc='vi ~/.bashrc_xtras'
alias fxgrep='find . | xargs grep'
alias fgrep='find . | grep'
export EDITOR='vim'
export GREPLOC=/bin/grep


#######################Per-machine configurations###############################
case $HOSTNAME in
tw-mbp-rbarry)
  export GREPLOC=/usr/bin/grep
  export PC_PREFERRED=$PC_GREEN
  export ESC_PREFERRED=$ESC_GREEN
  ;;
ron-desktop)
  export PC_PREFERRED=$PC_BROWN
  export ESC_PREFERRED=$ESC_BROWN
  export PATH=$PATH:$HOME/bin/cygwin
  ;;
box481.*)
  export PC_PREFERRED=$PC_CYAN
  export ESC_PREFERRED=$ESC_CYAN
  export STATUS_LINE_SUPPORT=linux
  ;;
perforce)
  export PC_PREFERRED=$PC_BLUE
  export ESC_PREFERRED=$ESC_BLUE
  export STATUS_LINE_SUPPORT=linux
  ;;
esac
################################################################################

source ~/.bashrc_remote

case $TERM in
  xterm|screen|xterm-256color)
    export SUPPORTS_STATUS_LINE="true"
    ;;
  *)
    export SUPPORTS_STATUS_LINE="false"
    ;;
esac

export PATH=$PATH:~/bin

export COMP_TMP="$HOME/tmp/$BASHPID.sh"
bind -x '"\eo":"expand_scm -o $COMP_TMP; source $COMP_TMP; rm $COMP_TMP"'
bind -x '"\en":"expand_scm -c $COMP_TMP; source $COMP_TMP; rm $COMP_TMP"'
bind -x '"\eh":"expand_history $COMP_TMP; source $COMP_TMP; rm $COMP_TMP"'

source ~/bin/acd_func.sh

LOGFILE="$HOME/bashlogs/$BASHPID"

################################################################################
#I want these commands to always use color, unless the command is being
#redirected to a file.  I'm sure I'll have to make changes as I find issues.
function a {
  if [[ "$CMD" =~ '>' ]]; then
    ls -al --color=auto "$@"
  else
    ls -al --color=always "$@" | comify -f 4
  fi
}

function grep {
  if [[ "$CMD" =~ '>' ]]; then
    $GREPLOC --color=auto "$@"
  else
    $GREPLOC --color=always "$@"
  fi
}

#This one exists specifically to hilight output, so why protect it from
#redirection?
function hl {
  egrep --color=always "(^)|($1)"
}
################################################################################


#Todo:
# * Add total logging: write $CMD, it's return value, start and end time to a
#   log file somewhere?
# * Get rid of hostname when you're on localhost?  (how?)
# * (on fit-pc, anyway) I'm still seeing the previous command flash up when a
#   blank line is entered
# * move the color definitions to a different file?
#If you put slashes in here, make SURE they are escaped with a backslash!!!
replace_substrings() {
    if [ $BASE == $PWD ]; then
        BACKREF=$1
        CRUFT=$2
        SUB=$3
        SUB_BNW=$4
        BASE=`echo $PWD|sed -e "s/^$CRUFT.*/$SUB/g"`
        BASE_BNW=`echo $PWD|sed -e "s/^$CRUFT.*/$SUB_BNW/g"`
        TRIM=`echo $PWD|sed -e "s/^$CRUFT\(.*\)/$BACKREF/g"`
    fi
}

gen_prompt_text() {
    LAST_RETURN_VAL=$?
    #echo $LAST_RETURN_VAL >> $LOGFILE
    #date >> "$LOGFILE"
    #echo >> "$LOGFILE"

    if [ $LAST_RETURN_VAL == 0 ]; then
        PC_BASE_COL=$PC_PREFERRED
        ESC_BASE_COL=$ESC_PREFERRED
    else
        PC_BASE_COL=$PC_RED
        ESC_BASE_COL=$ESC_RED
    fi

    HOST_SHORT=`hostname | cut -f1 -d.`

    BASE=$PWD
    TRIM=$PWD

    #replace_substrings takes;
    # * This is the worst bit, and I'll try to figure it out later.  You
    #   have to provide the regular expression backreference ONE BEYOND the
    #   last one you use.  If you don't use any (or you don't know what I'm
    #   talking about, use "\1".  If you use one backreference in the
    #   second argument, use "\2".  Etc.  It's used to extract the last
    #   portion of your current working directory.
    # * a regular expression match for the bit you want to chop off at the
    #   beginning 
    # * the string to replace the regex with in colorized prompts.  You don't
    #   have to use color.  If you don't this argument and the next will be
    #   the same.
    # * the string to replace the regex with in colorless prompts.
    case $HOSTNAME in
    fzzt.*)
      replace_substrings "\1" ".usr.local.google.home.rbarry"\
           "$ESC_BOLD${ESC_GREEN}~${ESC_BASE_COL}$ESC_BOLD_OFF" "~"
      replace_substrings "\1" \
           ".google.src.cloud.rbarry.rbarry-get_[^n]*name"\
           "$ESC_BOLD${ESC_GREEN}{GDBN}${ESC_BASE_COL}$ESC_BOLD_OFF" "{GDBN}"
      replace_substrings "\1" ".google.src.cloud.rbarry.rbarry-trusted[^\/]*"\
           "$ESC_BOLD${ESC_GREEN}{TTW}${ESC_BASE_COL}$ESC_BOLD_OFF" "{TTW}"
      replace_substrings "\1" ".google.src.cloud.rbarry.rbarry-user_can_[^\/]*"\
           "$ESC_BOLD${ESC_GREEN}{UCCAD}${ESC_BASE_COL}$ESC_BOLD_OFF" "{UCCAD}"
      replace_substrings "\2" ".google.src.cloud.rbarry.rbarry-\([^\/]*\)"\
           "$ESC_BOLD${ESC_GREEN}{\\1}${ESC_BASE_COL}$ESC_BOLD_OFF" "{\\1}"
      ;;
    fit-pc)
      replace_substrings "\1" ".home.ronb"\
           "$ESC_BOLD${ESC_GREEN}~${ESC_BASE_COL}$ESC_BOLD_OFF" "~"
      ;;
    box481.*)
      replace_substrings "\1" ".home1.foodinio"\
           "$ESC_BOLD${ESC_GREEN}~${ESC_BASE_COL}$ESC_BOLD_OFF" "~"
      ;;
    esac

    # If none of the above clauses have matched, TRIM is all we're going to
    # display after the hostname, so clear BASE and BASE_BNW
    if [ "$BASE" == "$PWD" ]; then
      BASE=""
      BASE_BNW=""
    fi

    if [ ${#TRIM} -gt 37 ]; then
        #TRIM=`echo $TRIM|sed -e "s/^.*\(.\{37\}\)$/\\1/"`
        #TRIM="...$TRIM"
        TRIM=`echo $TRIM|sed -e "s/^.*\(.\{37\}\)$/...\\1/"`
    fi

    PROMPT_COL=`echo "$PC_BASE_COL$TRIM$PC_RESET" | sed -e "s/\([Gg]\)\([Oo]\)\([Oo]\)\([Gg]\)\([Ll]\)\([Ee]\)/$ESC_BOLD$ESC_BLUE\1$ESC_RED\2$ESC_BROWN\3$ESC_BLUE\4$ESC_GREEN\5$ESC_RED\6$ESC_BASE_COL$ESC_BOLD_OFF/g"`


    export PROMPT_BNW="$HOST_SHORT: $BASE_BNW$TRIM> "
    export PROMPT_COL="$PC_UNDER$PC_BASE_COL$HOST_SHORT$PC_UNDER_OFF: $BASE$PROMPT_COL> "
    if [ $SUPPORTS_STATUS_LINE == "true" ]; then
        export PS1="\[\033]0;$PROMPT_BNW\a\]$PROMPT_COL"
    else
        export PS1=$PROMPT_COL
    fi
}

export PROMPT_COMMAND='gen_prompt_text'

#TODO: The trap fires a number of times in the execution of a command.
#      How can I trim it down so the trap is turned off until the end of
#      next prompt generation phase AND use $BASH_COMMAND instead of this
#      ugly history | sed thing?  ($BASH_COMMAND, during the execution of
#      gen_prompt_text is "gen_prompt_text"
if [ $SUPPORTS_STATUS_LINE == "true" ]; then
    trap 'if [ "$BASH_COMMAND" == "gen_prompt_text" ]; then CMD=""; else CMD="$BASH_COMMAND";fi;echo -en "\033]0;$PROMPT_BNW $CMD\007"' DEBUG
    #trap 'if [ "$BASH_COMMAND" == "gen_prompt_text" ]; then CMD=""; else CMD=`history 1|sed -e "s/^[ ]*[0-9]*[ ]*//g"`;fi;echo -en "\e]0;$PROMPT_BNW $CMD\007"' DEBUG
fi
